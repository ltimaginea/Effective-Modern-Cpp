# ***条款 34：优先选用 lambda 式，而非 std::bind***

调用 `bind` 的一般形式为：

```cpp
auto newCallable = bind(callable, arg_list);
```

`bind` 生成的函数对象称为**绑定对象**。

**之所以说优先选用 `lambda` 式，而非 `std::bind` ，最主要的原因是 `lambda` 式具备更高的可读性。**

`bind` 无法直接使用重载函数，需要强制转型到适当的函数指针型别。之所以是因为， `bind` 的 callable 调用是通过函数指针发生的。但是 `lambda` 与 `bind` 不同， `lambda` 采用的是常规的函数唤起方式，这么一来， `lambda` 便不存在 `bind` 的重载问题。

同时相比 `lambda` 中调用其他函数时采用的常规函数唤起方式， `bind` 的通过函数指针发起的函数调用方式，其被编译器内联的可能性不大，因此使用 `lambda` 就有可能会生成比使用 `bind` 运行更快的代码。

绑定对象的所以实参（占位符参数）都是按**引用**传递的，因为此种对象的函数调用运算符利用了**完美转发**。

但是， `bind` 的那些不是占位符的参数默认是被**拷贝**到 `bind` 返回的可调用对象中。与 `lambda` 类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。这时，我们可以通过实施 `std::ref` 或者 `std::cref` 的方法达成按引用传递的效果。与 `bind` 一样，函数 `ref` 和 `cref` 也定义在头文件 `functional` 中。

## ***Tips***

- 优先选用 `lambda` ，而非 `bind` ，因为 `lambda` 比起使用 `bind` 而言，可读性更好、表达力更强、可能运行效率也更高。